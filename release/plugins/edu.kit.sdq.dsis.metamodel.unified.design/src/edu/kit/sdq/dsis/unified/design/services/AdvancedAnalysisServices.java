package edu.kit.sdq.dsis.unified.design.services;

import java.util.*;

import org.eclipse.emf.ecore.EObject;

import edu.kit.sdq.dsis.unified.design.actions.RequirementTraceHelper;
import unified.*;

/**
 * Advanced Analysis Services - UPDATED for Requirements Support
 * Provides model analysis services including requirement metrics.
 *
 * All calls to metamodel methods that are not yet generated (getRequirements,
 * getRelatedBlocks, getRelatedHazards, getPriority, getRequirementType,
 * getRelatedRequirements) are routed through RequirementTraceHelper so that
 * this class compiles and runs correctly even before the EMF code generator
 * has been re-run.
 */
public class AdvancedAnalysisServices {

    // =========================================================================
    // ModelMetrics inner class
    // =========================================================================

    /**
     * Model Metrics - UPDATED to include requirement metrics.
     */
    public static class ModelMetrics {
        // Architecture Metrics
        private int totalBlocks;
        private int totalConnections;
        private int cyclomaticComplexity;
        private double averageBlockDegree;

        // Safety Metrics
        private int totalHazards;
        private double hazardCoverage;

        // FMEA Metrics
        private int totalFMEAItems;
        private double fmeaCoverage;
        private double averageRPN;
        private int highRiskItems;
        private double autoGeneratedPercentage;

        // Traceability Metrics
        private double traceabilityDensity;
        private int traceabilityLinks;

        // Quality Scores
        private int completenessScore;
        private int consistencyScore;

        // Requirement Metrics
        private int totalRequirements;
        private int functionalRequirements;
        private int safetyRequirements;
        private int performanceRequirements;
        private int highPriorityRequirements;
        private int mediumPriorityRequirements;
        private int lowPriorityRequirements;
        private int requirementsWithTraces;
        private double requirementCoverage;
        private double avgTracesPerRequirement;
        private int requirementToBlockLinks;
        private int requirementToHazardLinks;
        private int requirementToFMEALinks;

        // Getters - Architecture
        public int getTotalBlocks()            { return totalBlocks; }
        public int getTotalConnections()        { return totalConnections; }
        public int getCyclomaticComplexity()    { return cyclomaticComplexity; }
        public double getAverageBlockDegree()   { return averageBlockDegree; }

        // Getters - Safety
        public int getTotalHazards()            { return totalHazards; }
        public double getHazardCoverage()       { return hazardCoverage; }

        // Getters - FMEA
        public int getTotalFMEAItems()          { return totalFMEAItems; }
        public double getFmeaCoverage()         { return fmeaCoverage; }
        public double getAverageRPN()           { return averageRPN; }
        public int getHighRiskItems()           { return highRiskItems; }
        public double getAutoGeneratedPercentage() { return autoGeneratedPercentage; }

        // Getters - Traceability
        public double getTraceabilityDensity()  { return traceabilityDensity; }
        public int getTraceabilityLinks()       { return traceabilityLinks; }

        // Getters - Quality
        public int getCompletenessScore()       { return completenessScore; }
        public int getConsistencyScore()        { return consistencyScore; }

        // Getters - Requirements
        public int getTotalRequirements()            { return totalRequirements; }
        public int getFunctionalRequirements()        { return functionalRequirements; }
        public int getSafetyRequirements()            { return safetyRequirements; }
        public int getPerformanceRequirements()       { return performanceRequirements; }
        public int getHighPriorityRequirements()      { return highPriorityRequirements; }
        public int getMediumPriorityRequirements()    { return mediumPriorityRequirements; }
        public int getLowPriorityRequirements()       { return lowPriorityRequirements; }
        public int getRequirementsWithTraces()        { return requirementsWithTraces; }
        public double getRequirementCoverage()        { return requirementCoverage; }
        public double getAvgTracesPerRequirement()    { return avgTracesPerRequirement; }
        public int getRequirementToBlockLinks()       { return requirementToBlockLinks; }
        public int getRequirementToHazardLinks()      { return requirementToHazardLinks; }
        public int getRequirementToFMEALinks()        { return requirementToFMEALinks; }
    }

    // =========================================================================
    // computeModelMetrics
    // =========================================================================

    /**
     * Compute comprehensive model metrics including requirements.
     */
    public ModelMetrics computeModelMetrics(UnifiedSystemModel model) {
        ModelMetrics metrics = new ModelMetrics();

        // ---- Architecture Metrics ----
        metrics.totalBlocks      = model.getSystemBlocks().size() + model.getRootBlocks().size();
        metrics.totalConnections = model.getBlockConnections().size();

        int totalEdges = model.getBlockConnections().size();
        int totalNodes = metrics.totalBlocks;
        metrics.cyclomaticComplexity = totalEdges - totalNodes + 2;

        if (totalNodes > 0) {
            metrics.averageBlockDegree = (2.0 * totalEdges) / totalNodes;
        }

        // ---- Safety Metrics ----
        metrics.totalHazards = model.getGlobalHazards().size();

        int blocksWithHazards = 0;
        for (SafetyCriticalBlock block : model.getRootBlocks()) {
            for (IntegratedHazard hazard : model.getGlobalHazards()) {
                if (hazard.getRelatedBlocks().contains(block)) {
                    blocksWithHazards++;
                    break;
                }
            }
        }
        if (!model.getRootBlocks().isEmpty()) {
            metrics.hazardCoverage = (double) blocksWithHazards / model.getRootBlocks().size();
        }

        // ---- FMEA Metrics ----
        int totalFMEAItems = 0;
        int autoGenerated  = 0;
        double totalRPN    = 0;
        int highRisk       = 0;

        for (FMEAAnalysis analysis : model.getFmeaAnalysis()) {
            for (FMEAItem item : analysis.getFmeaItems()) {
                totalFMEAItems++;
                if (item.isAutoGenerated()) autoGenerated++;
                int rpn = item.getSeverity() * item.getOccurrence() * item.getDetection();
                totalRPN += rpn;
                if (rpn > 100) highRisk++;
            }
        }

        metrics.totalFMEAItems = totalFMEAItems;
        metrics.highRiskItems  = highRisk;

        if (totalFMEAItems > 0) {
            metrics.averageRPN              = totalRPN / totalFMEAItems;
            metrics.autoGeneratedPercentage = (autoGenerated * 100.0) / totalFMEAItems;
        }

        int blocksWithFMEA = 0;
        for (SafetyCriticalBlock block : model.getRootBlocks()) {
            outer:
            for (FMEAAnalysis analysis : model.getFmeaAnalysis()) {
                for (FMEAItem item : analysis.getFmeaItems()) {
                    if (item.getAnalyzedComponent() == block) {
                        blocksWithFMEA++;
                        break outer;
                    }
                }
            }
        }
        if (!model.getRootBlocks().isEmpty()) {
            metrics.fmeaCoverage = (double) blocksWithFMEA / model.getRootBlocks().size();
        }

        // ---- Requirement Metrics (via helper) ----
        List<Requirement> requirements = RequirementTraceHelper.getRequirements(model);
        metrics.totalRequirements = requirements.size();

        int totalTraceSum = 0;
        for (Requirement req : requirements) {

            // Count by type
            Object reqType = RequirementTraceHelper.getRequirementType(req);
            if (reqType != null) {
                String typeStr = reqType.toString();
                if (typeStr.equals("FUNCTIONAL"))   metrics.functionalRequirements++;
                else if (typeStr.equals("SAFETY"))  metrics.safetyRequirements++;
                else if (typeStr.equals("PERFORMANCE")) metrics.performanceRequirements++;
            }

            // Count by priority
            Object priority = RequirementTraceHelper.getPriority(req);
            if (priority != null) {
                String prioStr = priority.toString();
                if (prioStr.equals("HIGH"))        metrics.highPriorityRequirements++;
                else if (prioStr.equals("MEDIUM")) metrics.mediumPriorityRequirements++;
                else if (prioStr.equals("LOW"))    metrics.lowPriorityRequirements++;
            }

            // Count traces
            int blockLinks  = RequirementTraceHelper.getRelatedBlocks(req).size();
            int hazardLinks = RequirementTraceHelper.getRelatedHazards(req).size();
            int fmeaLinks   = RequirementTraceHelper.countFMEALinksForRequirement(model, req);

            metrics.requirementToBlockLinks  += blockLinks;
            metrics.requirementToHazardLinks += hazardLinks;
            metrics.requirementToFMEALinks   += fmeaLinks;

            int totalReqLinks = blockLinks + hazardLinks + fmeaLinks;
            totalTraceSum += totalReqLinks;
            if (totalReqLinks > 0) metrics.requirementsWithTraces++;
        }

        if (metrics.totalRequirements > 0) {
            metrics.requirementCoverage     = (double) metrics.requirementsWithTraces / metrics.totalRequirements;
            metrics.avgTracesPerRequirement = (double) totalTraceSum / metrics.totalRequirements;
        }

        // ---- Traceability Metrics ----
        metrics.traceabilityLinks =
            metrics.requirementToBlockLinks +
            metrics.requirementToHazardLinks +
            metrics.requirementToFMEALinks +
            countHazardToBlockLinks(model) +
            countFMEAToComponentLinks(model) +
            countFMEAToFailureModeLinks(model) +
            countFMEAToHazardLinks(model) +
            model.getBlockConnections().size();

        int possibleLinks = metrics.totalBlocks * (metrics.totalBlocks - 1) / 2;
        if (possibleLinks > 0) {
            metrics.traceabilityDensity = (double) metrics.traceabilityLinks / possibleLinks;
        }

        // ---- Completeness Score ----
        double architectureCompleteness = metrics.totalBlocks > 0
            ? Math.min(100, (metrics.totalConnections * 100.0) / metrics.totalBlocks) : 0;
        double safetyCompleteness       = metrics.hazardCoverage * 100;
        double fmeaCompleteness         = metrics.fmeaCoverage * 100;
        double requirementCompleteness  = metrics.requirementCoverage * 100;

        metrics.completenessScore = (int) (
            (architectureCompleteness + safetyCompleteness + fmeaCompleteness + requirementCompleteness) / 4);

        // ---- Consistency Score ----
        int consistencyIssues = 0;

        for (SafetyCriticalBlock block : model.getRootBlocks()) {
            if (!hasAssociatedHazards(block, model))              consistencyIssues++;
            if (requiresFMEAValidation(block) && !hasFMEAAnalysis(block, model)) consistencyIssues++;
        }

        // Requirement consistency: safety requirements must link to a hazard or FMEA item
        for (Requirement req : requirements) {
            Object reqType = RequirementTraceHelper.getRequirementType(req);
            if (reqType != null && reqType.toString().equals("SAFETY")) {
                if (RequirementTraceHelper.getRelatedHazards(req).isEmpty() &&
                    RequirementTraceHelper.countFMEALinksForRequirement(model, req) == 0) {
                    consistencyIssues++;
                }
            }
        }

        int maxIssues = Math.max(1, model.getRootBlocks().size() + requirements.size());
        metrics.consistencyScore = Math.max(0, 100 - (consistencyIssues * 100 / maxIssues));

        return metrics;
    }

    // =========================================================================
    // Public helper methods (called from Sirius services)
    // =========================================================================

    public boolean hasAssociatedHazards(SafetyCriticalBlock block, UnifiedSystemModel model) {
        for (IntegratedHazard hazard : model.getGlobalHazards()) {
            if (hazard.getRelatedBlocks().contains(block)) return true;
        }
        return false;
    }

    public boolean hasAssociatedHazards(SafetyCriticalBlock block) {
        UnifiedSystemModel model = getModel(block);
        return model != null && hasAssociatedHazards(block, model);
    }

    public boolean requiresFMEAValidation(SafetyCriticalBlock block) {
        return block.getSafetyCriticality() == SafetyCriticalityLevel.HIGH ||
               block.getSafetyCriticality() == SafetyCriticalityLevel.CRITICAL;
    }

    // =========================================================================
    // FMEA item generation
    // =========================================================================

    /**
     * Generates FMEA items for all safety-critical blocks that have failure modes.
     *
     * Note: ActionStatus.PENDING is used if available; if the enum literal name
     * differs in your metamodel, adjust the fallback branch below.
     */
    public List<FMEAItem> generateFMEAItems(UnifiedSystemModel model) {
        List<FMEAItem> items = new ArrayList<>();

        for (SafetyCriticalBlock block : model.getRootBlocks()) {
            for (BlockFailureMode fm : block.getFailureModes()) {
                FMEAItem item = UnifiedFactory.eINSTANCE.createFMEAItem();
                item.setName("FMEA: " + block.getName() + " - " + fm.getName());
                item.setId("FMEA_" + System.currentTimeMillis() + "_" + items.size());
                item.setAnalyzedComponent(block);
                item.setFailureMode(fm);
                item.setSeverity(estimateSeverity(block, fm));
                item.setOccurrence(estimateOccurrence(fm));
                item.setDetection(5);
                item.setAutoGenerated(true);
                item.setActionStatus(resolveDefaultActionStatus());

                items.add(item);
            }
        }

        return items;
    }

    /**
     * Resolves the default ActionStatus enum literal used when creating auto-generated
     * FMEA items. Tries PENDING first; falls back to the first available literal if
     * PENDING does not exist in this version of the metamodel.
     */
    private ActionStatus resolveDefaultActionStatus() {
        try {
            return ActionStatus.IN_PROGRESS;
        } catch (IllegalArgumentException | NullPointerException e) {
            // PENDING literal not present — use first available value as a safe default
            ActionStatus[] values = ActionStatus.values();
            return values.length > 0 ? values[0] : null;
        }
    }

    // =========================================================================
    // Recommendations
    // =========================================================================

    public enum RecommendationType {
        SAFETY_IMPROVEMENT,
        RISK_MITIGATION,
        HAZARD_MITIGATION,
        COMPLETENESS,
        CONSISTENCY,
        PERFORMANCE,
        REQUIREMENT_TRACEABILITY
    }

    public static class Recommendation {
        private final RecommendationType type;
        private final String description;

        public Recommendation(RecommendationType type, String description) {
            this.type        = type;
            this.description = description;
        }

        public RecommendationType getType()    { return type; }
        public String getDescription()          { return description; }
    }

    public List<Recommendation> generateRecommendations(UnifiedSystemModel model) {
        List<Recommendation> recommendations = new ArrayList<>();
        ModelMetrics metrics = computeModelMetrics(model);

        if (metrics.getCompletenessScore() < 50)
            recommendations.add(new Recommendation(RecommendationType.COMPLETENESS,
                "Model completeness is below 50%. Add more hazard associations, FMEA items, and traceability links."));

        if (metrics.getHazardCoverage() < 0.5)
            recommendations.add(new Recommendation(RecommendationType.HAZARD_MITIGATION,
                "Hazard coverage is below 50%. Link more hazards to safety-critical blocks."));

        if (metrics.getFmeaCoverage() < 0.8)
            recommendations.add(new Recommendation(RecommendationType.COMPLETENESS,
                "FMEA coverage is below 80%. Perform FMEA analysis on more safety-critical blocks."));

        if (metrics.getAverageRPN() > 100)
            recommendations.add(new Recommendation(RecommendationType.RISK_MITIGATION,
                "Average RPN exceeds 100. Review and mitigate high-risk FMEA items."));

        if (metrics.getTraceabilityDensity() < 0.3)
            recommendations.add(new Recommendation(RecommendationType.COMPLETENESS,
                "Traceability density is below 30%. Add more links between architecture and safety elements."));

        if (metrics.getRequirementCoverage() < 0.5)
            recommendations.add(new Recommendation(RecommendationType.REQUIREMENT_TRACEABILITY,
                "Requirement coverage is below 50%. Link requirements to blocks, hazards, and FMEA items."));

        // Safety requirements without hazard/FMEA links
        if (metrics.getSafetyRequirements() > 0) {
            int unlinkedSafety = 0;
            for (Requirement req : RequirementTraceHelper.getRequirements(model)) {
                Object reqType = RequirementTraceHelper.getRequirementType(req);
                if (reqType != null && reqType.toString().equals("SAFETY")) {
                    if (RequirementTraceHelper.getRelatedHazards(req).isEmpty() &&
                        RequirementTraceHelper.countFMEALinksForRequirement(model, req) == 0) {
                        unlinkedSafety++;
                    }
                }
            }
            if (unlinkedSafety > 0)
                recommendations.add(new Recommendation(RecommendationType.REQUIREMENT_TRACEABILITY,
                    unlinkedSafety + " safety requirement(s) are not linked to hazards or FMEA items."));
        }

        // High-priority requirements with insufficient traces
        if (metrics.getHighPriorityRequirements() > 0) {
            int underTraced = 0;
            for (Requirement req : RequirementTraceHelper.getRequirements(model)) {
                Object priority = RequirementTraceHelper.getPriority(req);
                if (priority != null && priority.toString().equals("HIGH")) {
                    int traceCount = RequirementTraceHelper.getRelatedBlocks(req).size()
                                   + RequirementTraceHelper.getRelatedHazards(req).size()
                                   + RequirementTraceHelper.countFMEALinksForRequirement(model, req);
                    if (traceCount < 2) underTraced++;
                }
            }
            if (underTraced > 0)
                recommendations.add(new Recommendation(RecommendationType.REQUIREMENT_TRACEABILITY,
                    underTraced + " high-priority requirement(s) have insufficient traceability (< 2 links)."));
        }

        return recommendations;
    }

    // =========================================================================
    // Private helpers
    // =========================================================================

    private boolean hasFMEAAnalysis(SafetyCriticalBlock block, UnifiedSystemModel model) {
        for (FMEAAnalysis analysis : model.getFmeaAnalysis()) {
            for (FMEAItem item : analysis.getFmeaItems()) {
                if (item.getAnalyzedComponent() == block) return true;
            }
        }
        return false;
    }

    private int countHazardToBlockLinks(UnifiedSystemModel model) {
        int count = 0;
        for (IntegratedHazard hazard : model.getGlobalHazards())
            count += hazard.getRelatedBlocks().size();
        return count;
    }

    private int countFMEAToComponentLinks(UnifiedSystemModel model) {
        int count = 0;
        for (FMEAAnalysis analysis : model.getFmeaAnalysis())
            for (FMEAItem item : analysis.getFmeaItems())
                if (item.getAnalyzedComponent() != null) count++;
        return count;
    }

    private int countFMEAToFailureModeLinks(UnifiedSystemModel model) {
        int count = 0;
        for (FMEAAnalysis analysis : model.getFmeaAnalysis())
            for (FMEAItem item : analysis.getFmeaItems())
                if (item.getFailureMode() != null) count++;
        return count;
    }

    private int countFMEAToHazardLinks(UnifiedSystemModel model) {
        int count = 0;
        for (FMEAAnalysis analysis : model.getFmeaAnalysis())
            for (FMEAItem item : analysis.getFmeaItems())
                count += item.getRelatedHazards().size();
        return count;
    }

    private int estimateSeverity(SafetyCriticalBlock block, BlockFailureMode fm) {
        if (block.getAsilLevel() == ASILLevel.ASIL_D) return 10;
        if (block.getAsilLevel() == ASILLevel.ASIL_C) return 8;
        if (block.getAsilLevel() == ASILLevel.ASIL_B) return 6;
        return 4;
    }

    private int estimateOccurrence(BlockFailureMode fm) {
        double rate = fm.getFailureRate();
        if (rate > 0.001)   return 10;
        if (rate > 0.0001)  return 7;
        if (rate > 0.00001) return 5;
        return 3;
    }

    private UnifiedSystemModel getModel(EObject element) {
        EObject current = element;
        while (current != null) {
            if (current instanceof UnifiedSystemModel) return (UnifiedSystemModel) current;
            current = current.eContainer();
        }
        return null;
    }
    // =========================================================================
    // Methods called directly by MetricsDashboard odesign column expressions
    // These five were missing — every summary cell was blank because AQL could
    // not resolve them and silently returned null.
    // =========================================================================

    /**
     * HTI — Hazard Traceability Index.
     * Fraction of globalHazards that have at least one SafetyGoal referencing them.
     * odesign call: aql:self.computeHazardCoverage()
     * Threshold: = 1.00 (100%)
     */
    public Double computeHazardCoverage(UnifiedSystemModel model) {
        List<IntegratedHazard> hazards = model.getGlobalHazards();
        if (hazards == null || hazards.isEmpty()) return 1.0;
        java.util.Set<IntegratedHazard> covered = new java.util.HashSet<>();
        if (model.getSafetyGoals() != null) {
            for (SafetyGoal sg : model.getSafetyGoals()) {
                if (sg.getRelatedHazard() != null) covered.add(sg.getRelatedHazard());
            }
        }
        return (double) covered.size() / hazards.size();
    }

    /**
     * FLC — Failure Linkage Completeness.
     * Fraction of FMEAItems that have a failureMode linked.
     * odesign call: aql:self.computeFMEACoverage()
     * Threshold: = 1.00 (100%)
     */
    public Double computeFMEACoverage(UnifiedSystemModel model) {
        List<FMEAAnalysis> analyses = model.getFmeaAnalysis();
        if (analyses == null || analyses.isEmpty()) return 1.0;
        int total = 0, linked = 0;
        for (FMEAAnalysis fa : analyses) {
            if (fa.getFmeaItems() == null) continue;
            for (FMEAItem item : fa.getFmeaItems()) {
                total++;
                if (item.getFailureMode() != null) linked++;
            }
        }
        return total == 0 ? 1.0 : (double) linked / total;
    }

    /**
     * TDS — Traceability Density Score.
     * Ratio of actual cross-layer traceability links to maximum possible links
     * across the SG→FSR→TSR→Block→FMEA→Mechanism chain.
     * odesign call: aql:self.computeTraceabilityDensity()
     * Threshold: >= 0.80 (80%)
     */
    public Double computeTraceabilityDensity(UnifiedSystemModel model) {
        int actual = 0, maximum = 0;

        // SafetyGoal → Hazard + FSR allocations
        if (model.getSafetyGoals() != null) {
            for (SafetyGoal sg : model.getSafetyGoals()) {
                maximum += 2;
                if (sg.getRelatedHazard() != null) actual++;
                if (sg.getAllocatedTo()   != null) actual += sg.getAllocatedTo().size();
            }
        }
        // FSR → TSR refinements + Block implementations
        if (model.getFunctionalRequirements() != null) {
            for (FunctionalSafetyRequirement fsr : model.getFunctionalRequirements()) {
                maximum += 2;
                if (fsr.getRefinedTo()     != null) actual += fsr.getRefinedTo().size();
                if (fsr.getImplementedBy() != null) actual += fsr.getImplementedBy().size();
            }
        }
        // TSR → Block realizations + FMEA verifications
        if (model.getTechnicalRequirements() != null) {
            for (TechnicalSafetyRequirement tsr : model.getTechnicalRequirements()) {
                maximum += 2;
                if (tsr.getRealizedBy() != null) actual += tsr.getRealizedBy().size();
                if (tsr.getVerifiedBy() != null) actual += tsr.getVerifiedBy().size();
            }
        }
        // FMEA → Mechanism validations
        if (model.getFmeaAnalysis() != null) {
            for (FMEAAnalysis fa : model.getFmeaAnalysis()) {
                if (fa.getFmeaItems() == null) continue;
                for (FMEAItem item : fa.getFmeaItems()) {
                    maximum++;
                    if (item.getValidatesMechanisms() != null)
                        actual += item.getValidatesMechanisms().size();
                }
            }
        }
        return maximum == 0 ? 1.0 : Math.min(1.0, (double) actual / maximum);
    }

    /**
     * Completeness Score (0–100).
     * Weighted average of hazard coverage, FMEA coverage, TSR allocation, and
     * mechanism verification — all of which the odesign already reads individually.
     * odesign call: aql:self.computeCompletenessScore()
     */
    public Integer computeCompletenessScore(UnifiedSystemModel model) {
        double hti = computeHazardCoverage(model);
        double flc = computeFMEACoverage(model);
        double rar = computeRequirementAllocationRatio(model);
        double mvr = computeMechanismVerificationRate(model);
        return (int) Math.round((hti + flc + rar + mvr) / 4.0 * 100);
    }

    /**
     * Consistency Score (0–100).
     * Penalises each safety-critical block without a hazard association or FMEA item.
     * odesign call: aql:self.computeConsistencyScore()
     */
    public Integer computeConsistencyScore(UnifiedSystemModel model) {
        int issues = 0;
        for (SafetyCriticalBlock block : model.getRootBlocks()) {
            if (!hasAssociatedHazards(block, model))                   issues++;
            if (requiresFMEAValidation(block) && !hasFMEAAnalysis(block, model)) issues++;
        }
        int maxIssues = Math.max(1, model.getRootBlocks().size() * 2);
        return Math.max(0, 100 - (issues * 100 / maxIssues));
    }

    // =========================================================================
    // Additional helpers used by MetricsDashboard (count methods)
    // =========================================================================

    /** Total FMEA items across all FMEAAnalysis instances. */
    public Integer countTotalFMEAItems(UnifiedSystemModel model) {
        int count = 0;
        if (model.getFmeaAnalysis() != null)
            for (FMEAAnalysis fa : model.getFmeaAnalysis())
                if (fa.getFmeaItems() != null) count += fa.getFmeaItems().size();
        return count;
    }

    /** Count FMEA items whose RPN exceeds 100. */
    public Integer countHighRiskItems(UnifiedSystemModel model) {
        int count = 0;
        if (model.getFmeaAnalysis() != null)
            for (FMEAAnalysis fa : model.getFmeaAnalysis())
                if (fa.getFmeaItems() != null)
                    for (FMEAItem item : fa.getFmeaItems())
                        if (item.getSeverity() * item.getOccurrence() * item.getDetection() > 100)
                            count++;
        return count;
    }

    /** Average RPN across all FMEA items; returns 0.0 if no items. */
    public Double computeAverageRPN(UnifiedSystemModel model) {
        int total = 0; double sum = 0;
        if (model.getFmeaAnalysis() != null)
            for (FMEAAnalysis fa : model.getFmeaAnalysis())
                if (fa.getFmeaItems() != null)
                    for (FMEAItem item : fa.getFmeaItems()) {
                        sum += item.getSeverity() * item.getOccurrence() * item.getDetection();
                        total++;
                    }
        return total == 0 ? 0.0 : sum / total;
    }

    /** Cyclomatic complexity: edges - nodes + 2. */
    public Integer computeCyclomaticComplexity(UnifiedSystemModel model) {
        int nodes = model.getSystemBlocks().size() + model.getRootBlocks().size();
        int edges = model.getBlockConnections().size();
        return edges - nodes + 2;
    }

    /** Average block degree: 2*edges / nodes. */
    public Double computeAverageBlockDegree(UnifiedSystemModel model) {
        int nodes = model.getSystemBlocks().size() + model.getRootBlocks().size();
        int edges = model.getBlockConnections().size();
        return nodes == 0 ? 0.0 : (2.0 * edges) / nodes;
    }

    // =========================================================================

    public Double computeMetamodelCoverageRatio1(UnifiedSystemModel model) {
        int populated = 0;
        if (model.getGlobalHazards()         != null && !model.getGlobalHazards().isEmpty())          populated++;
        if (model.getSafetyGoals()            != null && !model.getSafetyGoals().isEmpty())            populated++;
        if (model.getFunctionalRequirements() != null && !model.getFunctionalRequirements().isEmpty()) populated++;
        if (model.getTechnicalRequirements()  != null && !model.getTechnicalRequirements().isEmpty())  populated++;
        if (model.getSafetyMechanisms()       != null && !model.getSafetyMechanisms().isEmpty())       populated++;
        if (model.getFmeaAnalysis()           != null && !model.getFmeaAnalysis().isEmpty())           populated++;
        if (model.getRootBlocks()             != null && !model.getRootBlocks().isEmpty())             populated++;
        if (model.getSystemBlocks()           != null && !model.getSystemBlocks().isEmpty())           populated++;
        if (model.getAnalysisMetadata()       != null)                                                 populated++;
        return populated / 9.0;
    }

    /**
     * RAR — Requirement Allocation Ratio.
     * Fraction of TechnicalSafetyRequirements that have at least one
     * realizedBy block assigned.
     *
     * Called by odesign: aql:self.computeRequirementAllocationRatio()
     * where self : UnifiedSystemModel
     *
     * Threshold (GQM plan): >= 0.95
     */
    public Double computeRequirementAllocationRatio1(UnifiedSystemModel model) {
        List<TechnicalSafetyRequirement> tsrs = model.getTechnicalRequirements();
        if (tsrs == null || tsrs.isEmpty()) return 1.0;
        long allocated = tsrs.stream()
            .filter(tsr -> tsr.getRealizedBy() != null && !tsr.getRealizedBy().isEmpty())
            .count();
        return (double) allocated / tsrs.size();
    }

    /**
     * MVR — Mechanism Verification Rate.
     * Fraction of SafetyMechanisms that have at least one validatedBy
     * FMEA item linked.
     *
     * Called by odesign: aql:self.computeMechanismVerificationRate()
     * where self : UnifiedSystemModel
     *
     * Threshold (GQM plan): >= 0.85
     */
    public Double computeMechanismVerificationRate(UnifiedSystemModel model) {
        List<SafetyMechanism> mechanisms = model.getSafetyMechanisms();
        if (mechanisms == null || mechanisms.isEmpty()) return 1.0;
        long verified = mechanisms.stream()
            .filter(sm -> sm.getValidatedBy() != null && !sm.getValidatedBy().isEmpty())
            .count();
        return (double) verified / mechanisms.size();
    }

    /**
     * Overall Status — aggregates all six metrics against their GQM thresholds
     * and returns either "ALL PASS" or a string listing the failing metric codes.
     *
     * Called by odesign: aql:self.computeOverallStatus()
     * where self : UnifiedSystemModel
     *
     * Thresholds:
     *   MCR >= 0.90  (9/9 concept categories)
     *   HTI  = 1.00  (all hazards covered by a safety goal)
     *   RAR >= 0.95  (95% of TSRs allocated to blocks)
     *   FLC  = 1.00  (all FMEA items have a failure mode)
     *   TDS >= 0.80  (traceability density across layers)
     *   MVR >= 0.85  (85% of mechanisms validated by FMEA)
     */
        public Double computeMetamodelCoverageRatio(UnifiedSystemModel model) {
        int populated = 0;
        if (model.getGlobalHazards()         != null && !model.getGlobalHazards().isEmpty())          populated++;
        if (model.getSafetyGoals()            != null && !model.getSafetyGoals().isEmpty())            populated++;
        if (model.getFunctionalRequirements() != null && !model.getFunctionalRequirements().isEmpty()) populated++;
        if (model.getTechnicalRequirements()  != null && !model.getTechnicalRequirements().isEmpty())  populated++;
        if (model.getSafetyMechanisms()       != null && !model.getSafetyMechanisms().isEmpty())       populated++;
        if (model.getFmeaAnalysis()           != null && !model.getFmeaAnalysis().isEmpty())           populated++;
        if (model.getRootBlocks()             != null && !model.getRootBlocks().isEmpty())             populated++;
        if (model.getSystemBlocks()           != null && !model.getSystemBlocks().isEmpty())           populated++;
        if (model.getAnalysisMetadata()       != null)                                                 populated++;
        return populated / 9.0;
    }

    /**
     * RAR — Requirement Allocation Ratio.
     * Fraction of TSRs that have at least one realizedBy block assigned.
     * Called by odesign: aql:self.computeRequirementAllocationRatio()
     * Threshold: >= 0.95
     */
    public Double computeRequirementAllocationRatio(UnifiedSystemModel model) {
        List<TechnicalSafetyRequirement> tsrs = model.getTechnicalRequirements();
        if (tsrs == null || tsrs.isEmpty()) return 1.0;
        int allocated = 0;
        for (TechnicalSafetyRequirement tsr : tsrs) {
            if (tsr.getRealizedBy() != null && !tsr.getRealizedBy().isEmpty()) allocated++;
        }
        return (double) allocated / tsrs.size();
    }

    /**
     * MVR — Mechanism Verification Rate.
     * Fraction of SafetyMechanisms with at least one validatedBy FMEA item.
     * Called by odesign: aql:self.computeMechanismVerificationRate()
     * Threshold: >= 0.85
     */
    public Double computeMechanismVerificationRate1(UnifiedSystemModel model) {
        List<SafetyMechanism> mechanisms = model.getSafetyMechanisms();
        if (mechanisms == null || mechanisms.isEmpty()) return 1.0;
        int verified = 0;
        for (SafetyMechanism sm : mechanisms) {
            if (sm.getValidatedBy() != null && !sm.getValidatedBy().isEmpty()) verified++;
        }
        return (double) verified / mechanisms.size();
    }

    /**
     * Overall Status — evaluates all six GQM metrics and returns either
     * "ALL PASS" or "GAPS: HTI FLC ..." listing failing metric codes.
     *
     * Called by odesign: aql:self.computeOverallStatus()
     *
     * All metric logic is inlined (NOT delegated to computeHazardCoverage() etc.)
     * because those methods are in Services.java, not in this class.
     *
     * Thresholds: MCR>=0.90, HTI=1.00, RAR>=0.95, FLC=1.00, TDS>=0.80, MVR>=0.85
     */
    public String computeOverallStatus(UnifiedSystemModel model) {

        // MCR
        double mcr = computeMetamodelCoverageRatio1(model);

        // HTI — fraction of hazards covered by a SafetyGoal
        double hti;
        List<IntegratedHazard> hazards = model.getGlobalHazards();
        if (hazards == null || hazards.isEmpty()) {
            hti = 1.0;
        } else {
            java.util.Set<IntegratedHazard> covered = new java.util.HashSet<>();
            if (model.getSafetyGoals() != null) {
                for (SafetyGoal sg : model.getSafetyGoals()) {
                    if (sg.getRelatedHazard() != null) covered.add(sg.getRelatedHazard());
                }
            }
            hti = (double) covered.size() / hazards.size();
        }

        // RAR
        double rar = computeRequirementAllocationRatio1(model);

        // FLC — fraction of FMEA items with a failureMode linked
        double flc;
        List<FMEAAnalysis> analyses = model.getFmeaAnalysis();
        if (analyses == null || analyses.isEmpty()) {
            flc = 1.0;
        } else {
            int totalItems = 0, linkedItems = 0;
            for (FMEAAnalysis fa : analyses) {
                if (fa.getFmeaItems() == null) continue;
                for (FMEAItem item : fa.getFmeaItems()) {
                    totalItems++;
                    if (item.getFailureMode() != null) linkedItems++;
                }
            }
            flc = totalItems == 0 ? 1.0 : (double) linkedItems / totalItems;
        }

        // TDS — actual cross-layer links / maximum possible links
        double tds;
        {
            int actual = 0, maximum = 0;
            if (model.getSafetyGoals() != null) {
                maximum += model.getSafetyGoals().size() * 2;
                for (SafetyGoal sg : model.getSafetyGoals()) {
                    if (sg.getRelatedHazard() != null) actual++;
                    if (sg.getAllocatedTo()   != null) actual += sg.getAllocatedTo().size();
                }
            }
            if (model.getFunctionalRequirements() != null) {
                maximum += model.getFunctionalRequirements().size() * 2;
                for (FunctionalSafetyRequirement fsr : model.getFunctionalRequirements()) {
                    if (fsr.getRefinedTo()     != null) actual += fsr.getRefinedTo().size();
                    if (fsr.getImplementedBy() != null) actual += fsr.getImplementedBy().size();
                }
            }
            if (model.getTechnicalRequirements() != null) {
                maximum += model.getTechnicalRequirements().size() * 2;
                for (TechnicalSafetyRequirement tsr : model.getTechnicalRequirements()) {
                    if (tsr.getRealizedBy() != null) actual += tsr.getRealizedBy().size();
                    if (tsr.getVerifiedBy() != null) actual += tsr.getVerifiedBy().size();
                }
            }
            if (analyses != null) {
                for (FMEAAnalysis fa : analyses) {
                    if (fa.getFmeaItems() == null) continue;
                    for (FMEAItem item : fa.getFmeaItems()) {
                        maximum++;
                        if (item.getValidatesMechanisms() != null) actual += item.getValidatesMechanisms().size();
                    }
                }
            }
            tds = maximum == 0 ? 1.0 : (double) actual / maximum;
        }

        // MVR
        double mvr = computeMechanismVerificationRate(model);

        // Aggregate
        StringBuilder gaps = new StringBuilder();
        if (mcr < 0.90) gaps.append(" MCR");
        if (hti < 1.00) gaps.append(" HTI");
        if (rar < 0.95) gaps.append(" RAR");
        if (flc < 1.00) gaps.append(" FLC");
        if (tds < 0.80) gaps.append(" TDS");
        if (mvr < 0.85) gaps.append(" MVR");

        return gaps.length() == 0 ? "ALL PASS" : "GAPS:" + gaps.toString();
    }
}